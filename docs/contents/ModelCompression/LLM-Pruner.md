# LLM-Pruner: On the Structural Pruning of Large Language Models

**作者：** Xinyin Ma Gongfan Fang Xinchao Wang∗

**发表刊物/会议：** NeurIPS 

**发表年份：** 2023

**论文地址：** https://arxiv.org/abs/2305.11627

**代码地址：** https://github.com/horseee/LLM-Pruner





## 内容概要

&nbsp;&nbsp;剪枝+少量数据+少量训练 = 高效的Large Language Models压缩

&nbsp;&nbsp;大语言模型(LLMs, Large Language Models)在各种任务上展现出了强大的能力，这些能力很大程度上来自于模型巨大的参数量以及海量的训练语料。为了应对这些规模上存在的挑战，许多研究者开始关注大语言模型的轻量化问题。本文主要讨论一种基于结构化剪枝的方案，它能够“物理地”移除冗余的结构和参数，同时保留大部分原模型已经学习到的参数，实现高效的大语言模型压缩。

&nbsp;&nbsp;这篇文章介绍了一种名为LLM-Pruner的新型结构化剪枝方法，用于压缩大型语言模型（LLMs）。LLM-Pruner旨在以任务无关的方式压缩LLMs，同时最小化对原始训练数据集的依赖，并保留LLMs的多任务解决和语言生成能力。文章提出了一种依赖检测算法，用于识别模型中的所有依赖结构，并在任务无关设置下选择最佳剪枝组。然后，通过快速恢复阶段对剪枝后的模型进行后训练，使用有限的数据。

&nbsp;&nbsp;文章在三个LLMs（LLaMA-7B、Vicuna-7B和ChatGLM-6B）上验证了LLM-Pruner的有效性，并展示了压缩后的模型在零样本分类和生成方面仍具有令人满意的能力。实验结果表明，即使删除了20%的参数，剪枝后的模型仍保持了原始模型94.97%的性能。

## 主要解决问题/应用
&nbsp;&nbsp;首先，大语言模型的压缩与传统的神经网络(例如BERT, CNNs)的压缩等有什么差异呢。这需要从模型/数据/任务三个角度来分析:

1. 模型规模：第一个主要差异来自LLM的巨大参数量，这导致许多侧重训练（Training-heavy）的压缩方案，例如知识蒸馏变得较为困难.
2. 海量训练语料：许多LLMs经历了1万亿甚至更大规模的tokens上的训练，这导致许多依赖于原始数据或收集替代数据的方案变得尤其昂贵。
3. 任务无关的模型压缩：现有的压缩算法通常针对单一、特定的任务进行压缩，而LLMs是很优秀的多任务处理器，在压缩过程中我们不希望折损LLM的通用性和多功能性。

 &nbsp;&nbsp;LLM-Pruner 主要解决了以下问题：

1. 大型语言模型（LLM）的部署、推理和训练阶段面临的挑战，如模型规模庞大导致的计算需求高、参数众多导致延迟等问题。
2. 任务无关压缩，即在保留 LLM 作为多任务解决者和语言生成能力的同时，减小模型规模。
3. 减少对原始训练数据的依赖，降低数据传输和模型后训练的负担。
4. 快速压缩，通过 LoRA 技术在仅需要 50k 数据的情况下进行快速恢复。

&nbsp;&nbsp;LLM-Pruner 的应用包括：

1. 压缩大型语言模型，降低计算需求和延迟，提高部署效率。
2. 保留模型的多任务解决能力和语言生成能力，使其在各种任务中仍具有较高的性能。
3. 减少对原始训练数据的需求，降低数据传输和模型后训练的成本。
4. 快速压缩和恢复，提高模型部署和更新的速度。

## 主要使用方法/模型

 &nbsp;&nbsp;LLM-Pruner 的主要使用方法包括以下三个阶段：

1. 发现阶段：识别模型中的耦合结构，构建 LLM 的依赖图。通过将模型中的神经元作为初始触发器，触发依赖神经元，然后这些新触发的神经元可以作为后续触发器来识别依赖关系并激活其依赖的神经元。这个过程持续到没有新神经元被检测到为止，这些神经元形成一个组以供进一步剪枝。

2. 估计阶段：对耦合结构进行分组重要性估计。采用向量级重要性和元素级重要性两种方法来评估权重或参数的重要性。然后通过四种聚合策略（求和、乘积、最大值和仅最后一项）来评估组的重要性，根据预设的剪枝比例剪除低重要性的组。

3. 恢复阶段：使用 LoRA 技术对剪枝后的模型进行快速恢复。LoRA 通过将权重矩阵分解为低秩矩阵来减少训练复杂度，从而在有限的数据下快速恢复模型性能。



## 主要实验手段/数据集

 &nbsp;&nbsp;LLM-Pruner 的主要实验手段包括：

1. 使用三个不同的大型语言模型（LLaMA-7B、Vicuna-7B 和 ChatGLM-6B）进行实验。
2. 使用九个零样本分类数据集评估剪枝模型的生成质量和零样本分类性能，包括 BoolQ、PIQA、HellaSwag、WinoGrande、ARC-easy、ARC-challenge 和 OpenbookQA。
3. 使用 WikiText2 和 PTB 数据集进行零样本困惑度（PPL）分析。

&nbsp;&nbsp;实验数据集包括：

1. 用于构建依赖图的随机样本，如 Bookcorpus（用于 LLaMA 和 Vicuna）和 DailyDialog（用于 ChatGLM）。
2. 用于评估剪枝模型性能的零样本分类数据集，如 BoolQ、PIQA、HellaSwag、WinoGrande、ARC-easy、ARC-challenge 和 OpenbookQA。
3. 用于评估剪枝模型困惑度的 WikiText2 和 PTB 数据集。

## 创造性思考

 &nbsp;&nbsp;LLM-Pruner 的创造性思考主要体现在以下几个方面：

1. 任务无关压缩：LLM-Pruner 致力于在任务无关的情况下压缩大型语言模型，保留其多任务解决能力和语言生成能力。这使得压缩后的模型仍然具有广泛的应用潜力，而不仅仅是针对特定任务的专用模型。

2. 结构化剪枝：LLM-Pruner 通过识别模型中的耦合结构并对其进行分组，实现了结构化剪枝。这有助于在剪枝过程中保持模型的完整性，避免引入不匹配的中间表示。

3. 快速恢复：LLM-Pruner 使用 LoRA 技术对剪枝后的模型进行快速恢复。这使得模型在有限的数据下能够快速恢复性能，降低了训练复杂度和时间成本。

4. 自动化依赖检测：LLM-Pruner 能够自动检测模型中的耦合结构，无需手动设计。这使得剪枝过程更加高效且易于实现。

5. 减少对原始训练数据的依赖：LLM-Pruner 通过使用公共数据集或手动创建的样本作为替代资源，减少了对原始训练数据的依赖。这降低了数据传输和模型后训练的负担，使得压缩过程更加高效。

## 批判式思考

&nbsp;&nbsp;尽管 LLM-Pruner 在压缩大型语言模型方面取得了显著成果，但仍存在一些潜在的问题和局限性：

1. 高压缩率的挑战：当使用较高的压缩率（如 50% 参数削减）时，模型性能可能会显著下降。在这种情况下，仅通过快速恢复可能无法完全恢复原始模型的性能。因此，如何在高压缩率下保持模型性能仍然是一个具有挑战性的问题。

2. 剪枝策略的通用性：LLM-Pruner 的剪枝策略可能不适用于所有类型的大型语言模型。不同的模型结构可能需要不同的剪枝策略和重要性估计方法。因此，LLM-Pruner 可能需要针对特定模型进行调整和优化。

3. 外部数据的影响：虽然 LLM-Pruner 使用外部数据进行快速恢复，但这些数据可能与原始训练数据存在差异。这可能导致模型在某些任务上的性能下降。因此，在选择外部数据时需要谨慎，以确保数据的质量和相关性。

4. 剪枝过程中的损失：在剪枝过程中，可能会损失一些有用的信息。这可能导致模型在某些任务上的性能下降。为了解决这个问题，可以尝试使用更精细的剪枝策略，以减少信息损失。

5. 可解释性：LLM-Pruner 的剪枝过程可能难以解释，这使得用户难以理解模型压缩的原因和影响。为了提高可解释性，可以尝试开发更直观的剪枝策略和可视化工具。

## 讨论 


1. 大模型的裁剪和其他模型的裁剪有何区别？
    大型语言模型（LLM）的裁剪与其他模型的裁剪在以下几个方面存在区别：

   1. 模型规模：大型语言模型通常具有数十亿甚至数千亿个参数，而其他模型可能只有几百万或几千万个参数。因此，LLM 的裁剪需要处理更大规模的参数和结构，这使得裁剪过程更加复杂和计算密集。

   2. 结构复杂性：大型语言模型的结构通常更加复杂，包括多层、多头注意力机制等。这使得识别和处理耦合结构变得更加困难，需要设计更复杂的剪枝策略。

   3. 任务多样性：大型语言模型通常具有更广泛的任务适应性，可以处理多种自然语言处理任务。因此，在裁剪过程中需要考虑到模型在不同任务上的性能，以实现任务无关的压缩。

   4. 训练数据量：大型语言模型的训练数据量通常非常庞大，达到数千亿甚至数万亿个标记。这使得在裁剪过程中依赖原始训练数据变得不切实际，需要寻找其他方法来减少对原始数据的依赖。

   5. 计算资源：由于大型语言模型的规模和复杂性，裁剪过程可能需要大量的计算资源。因此，需要设计高效的裁剪策略和恢复方法，以减少计算成本和时间。

   总之，大型语言模型的裁剪与其他模型的裁剪在模型规模、结构复杂性、任务多样性、训练数据量和计算资源等方面存在显著差异。为了有效地裁剪大型语言模型，需要针对这些差异设计专门的裁剪策略和方法。
  
2. 怎么保证裁剪后的模型在较小的数据集上微调性能提升？

    为了确保裁剪后的模型在较小的数据集上进行微调时性能得到提升，可以采取以下策略：
    
    1. 选择合适的裁剪策略：使用结构化裁剪策略，如 LLM-Pruner，可以识别模型中的耦合结构并有针对性地进行裁剪。这有助于在保留模型功能的同时减小模型规模，从而提高微调效果。
    
    2. 使用高效的微调方法：采用低秩近似方法（如 LoRA）进行快速微调，可以减少训练复杂度和计算成本。这种方法只需要训练少量的额外参数，从而在有限的数据下快速恢复模型性能。
    
    3. 选择合适的外部数据集：在微调过程中，选择合适的外部数据集至关重要。数据集应具有足够的多样性和质量，以便模型能够从中学习到有用的信息。同时，数据集应与原始训练数据具有一定的相关性，以避免引入过多的噪声。
    
    4. 调整超参数：在微调过程中，调整学习率、批次大小等超参数，以找到最佳的训练配置。合适的超参数设置可以提高模型在有限数据下的泛化能力。
    
    5. 监控过拟合：在微调过程中，密切关注模型在验证集上的性能，以避免过拟合。如果发现过拟合迹象，可以采取正则化方法（如 L1、L2 正则化）或提前停止训练来减轻过拟合问题。
    
    6. 多次尝试和调整：微调过程可能需要多次尝试和调整。通过尝试不同的裁剪策略、微调方法和超参数设置，可以找到最佳的组合以实现性能提升。
    
    总之，要确保裁剪后的模型在较小的数据集上微调性能提升，需要选择合适的裁剪策略、使用高效的微调方法、选择合适的外部数据集、调整超参数、监控过拟合并多次尝试和调整。通过这些策略，可以在有限的数据下实现模型性能的提升。

3. 有什么可以改进的地方？
   虽然这篇文章提出了一种有效的大型语言模型压缩方法，但仍然有一些可以改进的地方：

   1. 实验结果的可解释性：文章中提供了一些实验结果，但可以进一步提供可视化结果，如模型性能随压缩比例变化的曲线图，以便更直观地展示压缩方法的效果。

   2. 模型泛化性能：文章主要关注了零样本任务的性能，但可以进一步评估模型在有监督任务和多任务学习场景下的性能，以展示压缩方法在不同任务和场景下的泛化能力。

   3. 模型稳定性：文章中提到了在高压缩率下模型性能下降的问题。可以进一步研究模型稳定性，探讨在不同压缩率下模型性能下降的原因，以及如何提高模型稳定性。

   4. 剪枝策略的多样性：文章中主要使用了一种剪枝策略。可以尝试使用不同的剪枝策略，如基于梯度的剪枝、基于权重的剪枝等，以找到更适合大型语言模型的剪枝方法。

   5. 与其他压缩方法的比较：文章中提到了与其他压缩方法（如知识蒸馏、量化等）的比较，但可以进一步详细比较这些方法在大型语言模型压缩任务中的优缺点，以帮助读者更好地理解各种方法的特点和适用场景。

   6. 模型部署和实际应用：文章主要关注了模型压缩方法本身，可以进一步讨论压缩后的模型在实际应用中的部署问题，如内存限制、计算资源限制等，以及如何在实际应用中权衡模型性能和压缩效果。

   总之，这篇文章在大型语言模型压缩方面取得了很好的成果，但仍有一些可以改进的地方，如提高实验结果的可解释性、评估模型泛化性能、研究模型稳定性、尝试不同的剪枝策略、与其他压缩方法的比较以及讨论模型部署和实际应用等。
  
## 参考链接

- <https://zhuanlan.zhihu.com/p/630902012>